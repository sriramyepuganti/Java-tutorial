<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA</title>
</head>

<body>
    <h1>usages</h1>
    <ul>
        <li>Mobile applications (specially Android apps)</li>
        <li>Desktop applications</li>
        <li>Web applications</li>
        <li>Web servers and application servers</li>
        <li>Games</li>
        <li>Database connection</li>
    </ul>
    <h1>Features</h1>
    <ul>
        <li>Java works on different platforms (Windows, Mac, Linux, Raspberry Pi, etc.)</li>
        <li>It is open-source and free</li>
        <li>It is secure, fast and powerful</li>
        <li>It has a huge community support</li>
        <li>Object-Oriented</li>
        <li>Platform Independent</li>
        <li>Robust</li>
        <li>Multi-Threaded</li>
    </ul>
    <h1>Install</h1>
    <ul>
        <li>Download latest Jdk and install.</li>
        <li>If it is ubuntu or Mac no setup is required. for window setup ENV variables</li>
    </ul>
    <h1>JSHELL</h1>
    <ul>
        <li>interactive tool for learning the Java programming language and prototyping Java code.</li>
        <li>exit: /exit</li>
    </ul>
    <h1>JVM: java virtual machine</h1>
    <ul>
        <li>H/W => OS => JVM</li>
        <li>It is an abstract machine that provides the runtime environment in which Java bytecode can be executed</li>
        <li>JVM plays a crucial role in the execution of Java code and is an important component of the Java platform
        </li>
        <li>we can divide jvm into two parts. 1. stack memory. 2. Heap memory</li>
        <li>stack memory: it stores values in key, value format (like 2*n table)</li>
        <li>it stores local variable. varaible name as key and value as value</li>
        <li>if it finds object creation like (Calc val = new Calc)</li>
        <li>it stores value in heap memeort in table (like 1*n table)</li>
        <li>table top contains unique memory addess and inside it store instance values and method value</li>
        <li>again each method calls (val.getData()) will be stored in seprate stacks</li>
        <li>heap conatins special thing for handling strings called STRING CONATSNT POOL. </li>
        <li>if it face same string (case senstive). then it will not create new refernce in memory. both will point to
            same memory</li>
    </ul>
    <h1>JRE: java runtime environment</h1>
    <ul>
        <li>H/W => os => JRE (inside jvm)</li>
        <li>it is a software package that provides the necessary libraries, Java Virtual Machine (JVM), and other
            components required to run Java applications.</li>
        <li>the JRE is a software package that provides the necessary components to run Java applications, including the
            JVM and Java class libraries.</li>
    </ul>
    <h1>JDK: java development kit</h1>
    <ul>
        <li>H/W => OS => JDK (INSIDE JRE (INSIDE JVM))</li>
        <li>It is a software development kit that includes the necessary tools and libraries to develop, compile, and
            debug Java applications.</li>
    </ul>
    <p>When you are working with text, it must be wrapped inside double quotations marks ""</p>
    <section>
        <h1>Data types</h1>
        <ul>
            <li>Primitive: Integer, Float, Character, Boolean</li>
            <li>non-primitive: String, Array, Classes</li>
        </ul>
        <h2>Primitive</h2>
        <ul>
            <li>Integer: Byte(1 byte), Short(2 byte), Int(4 byte), Long(8 byte)</li>
            <li>Float: Double(8 byte), Float(4 byte).</li>
            <li>Character: Character(2 byte)</li>
            <li>Boolean: (1 byte)</li>
        </ul>
        <h2>Default</h2>
        <ul>
            <li>for float default is double. ex: float f1 = 0.6; // double</li>
            <li>float f2 = 0.6f; // float type</li>
        </ul>
        <h2>Type conversion</h2>
        <ul>
            <li>type conversion in Java is the process of converting a value from one data type to another data type.
            </li>
            <li>Implicit type conversion occurs automatically when a value of a smaller data type is assigned to a
                variable of a larger data type,</li>
            <li>while explicit type conversion requires an explicit cast operator and can result in the loss of data.
            </li>
            <li>Widening Casting (automatically) - converting a smaller type to a larger type size
                byte -> short -> char -> int -> long -> float -> double</li>
            <li>Narrowing Casting (manually) - converting a larger type to a smaller size type
                double -> float -> long -> int -> char -> short -> byte</li>
            <li>Type promotion: it is a process that converts an atomic value from its original type to the type that is
                expected by an expression</li>
        </ul>

    </section>
    <h1>Operators</h1>
    <ul>
        <li>Arithmetic Operators: +, - ,*, /, %, ++, --</li>
        <li>Assignment operator: =, +=, -=, *=, /=, %= , &=, |=, >>= , <<=< /li>
        <li>Comparison Operators: >, <,==, !=,>=, <=< /li>
        <li>Logical Operators: &&, ||, !</li>
    </ul>
    <h1>Method Overloading</h1>
    <p>With method overloading, multiple methods can have the same name with different parameters</p>
    <h1>Scope</h1>
    <ul>
        <li>Method Scope: Variables declared directly inside a method are available anywhere in the method following the
            line of code in which they were declared:</li>
        <li>A local variable cannot be defined with "static" keyword.</li>
        <li>Block Scope: A block of code refers to all of the code between curly braces {}.</li>
    </ul>

    <h1>OOPS: object Object-Oriented programming</h1>
    <ul>
        <li>programming is about creating objects that contain both data and methods.</li>
        OOP is faster and easier to execute
        <li>OOP provides a clear structure for the programs</li>
        <li>OOP helps to keep the Java code DRY "Don't Repeat Yourself", and makes the code easier to maintain, modify
            and debug</li>
        <li>OOP makes it possible to create full reusable applications with less code and shorter development time</li>
        <li>properties or fields or attributes</li>
        <li>methods or behaviour</li>
    </ul>
    <h1>Access Modifiers: controls the access level</h1>
    <ul>
        <li>classes: public, default</li>
        <li>attributes, methods and constructors: public, default, private, protected</li>
    </ul>
    <h1>Non-Access Modifiers</h1>
    <ul>
        <li>classes: final, abstract</li>
        <li>attributes and methods: final, static, abstract, transient, synchronized, volatile</li>
    </ul>
    <h1>Naming convention</h1>
    <ul>
        <li>Class: start with uppercase. it should be nouns. ex: Color, BankAccount</li>
        <li>Interface: start with uppercase. it should adjective. ex: Runnable, Printiable</li>
        <li>varaiable, Method: start with lower case. ex: isTrue, getValue()</li>
        <li>Package: start with lower case. if has multiple words use .</li>
        <li>constants: use uppercase. ex: MAX_VALUE</li>
    </ul>
    <h1>IMP</h1>
    <ul>
        <li>Instance variable doesn't get memory at compile time. It gets memory at runtime when an object or instance
            is created</li>
        <li>The new keyword is used to allocate memory at runtime. All objects get memory in Heap memory area.</li>
        <li>Method Signature: Every method has a method signature. It is a part of the method declaration. It includes
            the method name and parameter list.</li>
        <li>It is called constructor because it constructs the values at the time of object creation. It is not
            necessary to write a constructor for a class. It is because java compiler creates a default constructor if
            your class doesn't have any.</li>
        <li>A Java constructor cannot be abstract, static, final, and synchronized</li>
        <li>Inheritance represents the IS-A relationship which is also known as a parent-child relationship.</li>
        <li>If a class have an entity reference, it is known as Aggregation. Aggregation represents HAS-A relationship.
        </li>
        <li>Instance Initializer block is used to initialize the instance data member. It run each time when object of
            the class is created.</li>
        <li>Runtime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is
            resolved at runtime rather than compile-time.</li>
        <li>Connecting a method call to the method body is known as binding.</li>
        <li>If there is any private, final or static method in a class, there is static binding.</li>
        <li>When type of the object is determined at run-time, it is known as dynamic binding.</li>
        <li>The wrapper class in Java provides the mechanism to convert primitive into object and object into primitive.
        </li>
        <li>java.util package: The java.util package provides the utility classes to deal with objects.</li>
        <li>Synchronization: Java synchronization works with objects in Multithreading.
        </li>
        <li>Serialization: We need to convert the objects into streams to perform the serialization. If we have a
            primitive value, we can convert it in objects through the wrapper classes.</li>
        <li>The automatic conversion of primitive data type into its corresponding wrapper class is known as autoboxing
        </li>
        <li>The automatic conversion of wrapper type into its corresponding primitive type is known as unboxing.</li>
        <li>There is only call by value in java, not call by reference. If we call a method passing a value, it is known
            as call by value. The changes being done in the called method, </li>
        <li>Java strictfp keyword ensures that you will get the same result on every platform if you perform operations
            in the floating-point variable.</li>
    </ul>
    <h1>JVM architecture:</h1>
    <p> stands for Java Virtual Machine. It is a software component that runs Java bytecode, allowing Java applications
        to run on any platform without the need for recompilation. The JVM architecture consists of several components
        that work together to execute Java code. Here's a simple explanation of each component:</p>
    <li>
        Class Loader
        The Class Loader is responsible for loading the classes required by the Java program. It loads the bytecode of
        the
        classes into the JVM's memory, making them available for execution.

    </li>
    <li>
        Runtime Data Area
        The Runtime Data Area is where the JVM stores all the data required during program execution. It is divided into
        several components, including the method area, heap, stack, and program counter.
    </li>
    <li>
        Execution Engine
        The Execution Engine is responsible for executing the bytecode instructions stored in the JVM's memory. It
        consists
        of two components: the interpreter and the just-in-time (JIT) compiler. The interpreter reads the bytecode and
        executes it directly, while the JIT compiler translates frequently executed bytecode into machine code for
        faster
        execution.
    </li>
    <li>
        Native Method Interface (JNI)
        The Native Method Interface is a programming interface that allows Java code to call native methods written in
        other
        programming languages, such as C or C++.
    </li>
    <li>
        Native Method Libraries
        The Native Method Libraries contain native methods written in other programming languages, such as C or C++.
        These
        methods can be called by the JVM using the JNI.
    </li>
    <img src="https://www.javainterviewpoint.com/wp-content/uploads/2016/01/JVM-Architecture.png" />
    <h1>JVM start up</h1>
    <ul>
        <li>loads intital class, using the bootstrap loader</li>
        <li>links the intial class</li>
        <li>initial it</li>
        <li>invoke public static void main</li>
        <li>for each class file jvm stores information in Method Area</li>
        <li>after loading each class file. jvm create an object of type java.lang.Class to represent the file in heap memory</li>
        <li>Method area: JVM creates run time constant pool for per class/ interface it loads into memory</li>
        <li>constant_pool tabel in the binary representation of class or interface</li>
        <li>Linking: ver</li>
    </ul>
</body>

</html>